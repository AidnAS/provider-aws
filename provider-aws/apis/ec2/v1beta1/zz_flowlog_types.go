/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type DestinationOptionsObservation struct {
}

type DestinationOptionsParameters struct {

	// +kubebuilder:validation:Optional
	FileFormat *string `json:"fileFormat,omitempty" tf:"file_format,omitempty"`

	// +kubebuilder:validation:Optional
	HiveCompatiblePartitions *bool `json:"hiveCompatiblePartitions,omitempty" tf:"hive_compatible_partitions,omitempty"`

	// +kubebuilder:validation:Optional
	PerHourPartition *bool `json:"perHourPartition,omitempty" tf:"per_hour_partition,omitempty"`
}

type FlowLogObservation struct {
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	TagsAll map[string]*string `json:"tagsAll,omitempty" tf:"tags_all,omitempty"`
}

type FlowLogParameters struct {

	// +kubebuilder:validation:Optional
	DestinationOptions []DestinationOptionsParameters `json:"destinationOptions,omitempty" tf:"destination_options,omitempty"`

	// +kubebuilder:validation:Optional
	EniID *string `json:"eniId,omitempty" tf:"eni_id,omitempty"`

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-aws/apis/iam/v1beta1.Role
	// +crossplane:generate:reference:extractor=github.com/upbound/official-providers/provider-aws/config/common.ARNExtractor()
	// +kubebuilder:validation:Optional
	IAMRoleArn *string `json:"iamRoleArn,omitempty" tf:"iam_role_arn,omitempty"`

	// +kubebuilder:validation:Optional
	IAMRoleArnRef *v1.Reference `json:"iamRoleArnRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	IAMRoleArnSelector *v1.Selector `json:"iamRoleArnSelector,omitempty" tf:"-"`

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-aws/apis/cloudwatchlogs/v1beta1.Group
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractParamPath("arn",true)
	// +kubebuilder:validation:Optional
	LogDestination *string `json:"logDestination,omitempty" tf:"log_destination,omitempty"`

	// +kubebuilder:validation:Optional
	LogDestinationRef *v1.Reference `json:"logDestinationRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	LogDestinationSelector *v1.Selector `json:"logDestinationSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	LogDestinationType *string `json:"logDestinationType,omitempty" tf:"log_destination_type,omitempty"`

	// +kubebuilder:validation:Optional
	LogFormat *string `json:"logFormat,omitempty" tf:"log_format,omitempty"`

	// +kubebuilder:validation:Optional
	LogGroupName *string `json:"logGroupName,omitempty" tf:"log_group_name,omitempty"`

	// +kubebuilder:validation:Optional
	MaxAggregationInterval *float64 `json:"maxAggregationInterval,omitempty" tf:"max_aggregation_interval,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-aws/apis/ec2/v1beta1.Subnet
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetIDRef *v1.Reference `json:"subnetIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	SubnetIDSelector *v1.Selector `json:"subnetIdSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Required
	TrafficType *string `json:"trafficType" tf:"traffic_type,omitempty"`

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-aws/apis/ec2/v1beta1.VPC
	// +kubebuilder:validation:Optional
	VPCID *string `json:"vpcId,omitempty" tf:"vpc_id,omitempty"`

	// +kubebuilder:validation:Optional
	VPCIDRef *v1.Reference `json:"vpcIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	VPCIDSelector *v1.Selector `json:"vpcIdSelector,omitempty" tf:"-"`
}

// FlowLogSpec defines the desired state of FlowLog
type FlowLogSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     FlowLogParameters `json:"forProvider"`
}

// FlowLogStatus defines the observed state of FlowLog.
type FlowLogStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        FlowLogObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// FlowLog is the Schema for the FlowLogs API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aws}
type FlowLog struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              FlowLogSpec   `json:"spec"`
	Status            FlowLogStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// FlowLogList contains a list of FlowLogs
type FlowLogList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []FlowLog `json:"items"`
}

// Repository type metadata.
var (
	FlowLog_Kind             = "FlowLog"
	FlowLog_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: FlowLog_Kind}.String()
	FlowLog_KindAPIVersion   = FlowLog_Kind + "." + CRDGroupVersion.String()
	FlowLog_GroupVersionKind = CRDGroupVersion.WithKind(FlowLog_Kind)
)

func init() {
	SchemeBuilder.Register(&FlowLog{}, &FlowLogList{})
}
