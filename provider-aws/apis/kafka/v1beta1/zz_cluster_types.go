/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type BrokerLogsObservation struct {
}

type BrokerLogsParameters struct {

	// +kubebuilder:validation:Optional
	CloudwatchLogs []CloudwatchLogsParameters `json:"cloudwatchLogs,omitempty" tf:"cloudwatch_logs,omitempty"`

	// +kubebuilder:validation:Optional
	Firehose []FirehoseParameters `json:"firehose,omitempty" tf:"firehose,omitempty"`

	// +kubebuilder:validation:Optional
	S3 []S3Parameters `json:"s3,omitempty" tf:"s3,omitempty"`
}

type BrokerNodeGroupInfoObservation struct {
}

type BrokerNodeGroupInfoParameters struct {

	// +kubebuilder:validation:Optional
	AzDistribution *string `json:"azDistribution,omitempty" tf:"az_distribution,omitempty"`

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-aws/apis/ec2/v1beta1.Subnet
	// +kubebuilder:validation:Optional
	ClientSubnets []*string `json:"clientSubnets,omitempty" tf:"client_subnets,omitempty"`

	// +kubebuilder:validation:Optional
	ClientSubnetsRefs []v1.Reference `json:"clientSubnetsRefs,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ClientSubnetsSelector *v1.Selector `json:"clientSubnetsSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ConnectivityInfo []ConnectivityInfoParameters `json:"connectivityInfo,omitempty" tf:"connectivity_info,omitempty"`

	// +kubebuilder:validation:Optional
	EBSVolumeSize *float64 `json:"ebsVolumeSize,omitempty" tf:"ebs_volume_size,omitempty"`

	// +kubebuilder:validation:Required
	InstanceType *string `json:"instanceType" tf:"instance_type,omitempty"`

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-aws/apis/ec2/v1beta1.SecurityGroup
	// +kubebuilder:validation:Optional
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityGroupsRefs []v1.Reference `json:"securityGroupsRefs,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	SecurityGroupsSelector *v1.Selector `json:"securityGroupsSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	StorageInfo []StorageInfoParameters `json:"storageInfo,omitempty" tf:"storage_info,omitempty"`
}

type ClientAuthenticationObservation struct {
}

type ClientAuthenticationParameters struct {

	// +kubebuilder:validation:Optional
	Sasl []SaslParameters `json:"sasl,omitempty" tf:"sasl,omitempty"`

	// +kubebuilder:validation:Optional
	TLS []TLSParameters `json:"tls,omitempty" tf:"tls,omitempty"`

	// +kubebuilder:validation:Optional
	Unauthenticated *bool `json:"unauthenticated,omitempty" tf:"unauthenticated,omitempty"`
}

type CloudwatchLogsObservation struct {
}

type CloudwatchLogsParameters struct {

	// +kubebuilder:validation:Required
	Enabled *bool `json:"enabled" tf:"enabled,omitempty"`

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-aws/apis/cloudwatchlogs/v1beta1.Group
	// +kubebuilder:validation:Optional
	LogGroup *string `json:"logGroup,omitempty" tf:"log_group,omitempty"`

	// +kubebuilder:validation:Optional
	LogGroupRef *v1.Reference `json:"logGroupRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	LogGroupSelector *v1.Selector `json:"logGroupSelector,omitempty" tf:"-"`
}

type ClusterObservation struct {
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	BootstrapBrokers *string `json:"bootstrapBrokers,omitempty" tf:"bootstrap_brokers,omitempty"`

	BootstrapBrokersPublicSaslIAM *string `json:"bootstrapBrokersPublicSaslIam,omitempty" tf:"bootstrap_brokers_public_sasl_iam,omitempty"`

	BootstrapBrokersPublicSaslScram *string `json:"bootstrapBrokersPublicSaslScram,omitempty" tf:"bootstrap_brokers_public_sasl_scram,omitempty"`

	BootstrapBrokersPublicTLS *string `json:"bootstrapBrokersPublicTls,omitempty" tf:"bootstrap_brokers_public_tls,omitempty"`

	BootstrapBrokersSaslIAM *string `json:"bootstrapBrokersSaslIam,omitempty" tf:"bootstrap_brokers_sasl_iam,omitempty"`

	BootstrapBrokersSaslScram *string `json:"bootstrapBrokersSaslScram,omitempty" tf:"bootstrap_brokers_sasl_scram,omitempty"`

	BootstrapBrokersTLS *string `json:"bootstrapBrokersTls,omitempty" tf:"bootstrap_brokers_tls,omitempty"`

	CurrentVersion *string `json:"currentVersion,omitempty" tf:"current_version,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	TagsAll map[string]*string `json:"tagsAll,omitempty" tf:"tags_all,omitempty"`

	ZookeeperConnectString *string `json:"zookeeperConnectString,omitempty" tf:"zookeeper_connect_string,omitempty"`

	ZookeeperConnectStringTLS *string `json:"zookeeperConnectStringTls,omitempty" tf:"zookeeper_connect_string_tls,omitempty"`
}

type ClusterParameters struct {

	// +kubebuilder:validation:Required
	BrokerNodeGroupInfo []BrokerNodeGroupInfoParameters `json:"brokerNodeGroupInfo" tf:"broker_node_group_info,omitempty"`

	// +kubebuilder:validation:Optional
	ClientAuthentication []ClientAuthenticationParameters `json:"clientAuthentication,omitempty" tf:"client_authentication,omitempty"`

	// +kubebuilder:validation:Required
	ClusterName *string `json:"clusterName" tf:"cluster_name,omitempty"`

	// +kubebuilder:validation:Optional
	ConfigurationInfo []ConfigurationInfoParameters `json:"configurationInfo,omitempty" tf:"configuration_info,omitempty"`

	// +kubebuilder:validation:Optional
	EncryptionInfo []EncryptionInfoParameters `json:"encryptionInfo,omitempty" tf:"encryption_info,omitempty"`

	// +kubebuilder:validation:Optional
	EnhancedMonitoring *string `json:"enhancedMonitoring,omitempty" tf:"enhanced_monitoring,omitempty"`

	// +kubebuilder:validation:Required
	KafkaVersion *string `json:"kafkaVersion" tf:"kafka_version,omitempty"`

	// +kubebuilder:validation:Optional
	LoggingInfo []LoggingInfoParameters `json:"loggingInfo,omitempty" tf:"logging_info,omitempty"`

	// +kubebuilder:validation:Required
	NumberOfBrokerNodes *float64 `json:"numberOfBrokerNodes" tf:"number_of_broker_nodes,omitempty"`

	// +kubebuilder:validation:Optional
	OpenMonitoring []OpenMonitoringParameters `json:"openMonitoring,omitempty" tf:"open_monitoring,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type ConfigurationInfoObservation struct {
}

type ConfigurationInfoParameters struct {

	// +kubebuilder:validation:Required
	Arn *string `json:"arn" tf:"arn,omitempty"`

	// +kubebuilder:validation:Required
	Revision *float64 `json:"revision" tf:"revision,omitempty"`
}

type ConnectivityInfoObservation struct {
}

type ConnectivityInfoParameters struct {

	// +kubebuilder:validation:Optional
	PublicAccess []PublicAccessParameters `json:"publicAccess,omitempty" tf:"public_access,omitempty"`
}

type EBSStorageInfoObservation struct {
}

type EBSStorageInfoParameters struct {

	// +kubebuilder:validation:Optional
	ProvisionedThroughput []ProvisionedThroughputParameters `json:"provisionedThroughput,omitempty" tf:"provisioned_throughput,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeSize *float64 `json:"volumeSize,omitempty" tf:"volume_size,omitempty"`
}

type EncryptionInTransitObservation struct {
}

type EncryptionInTransitParameters struct {

	// +kubebuilder:validation:Optional
	ClientBroker *string `json:"clientBroker,omitempty" tf:"client_broker,omitempty"`

	// +kubebuilder:validation:Optional
	InCluster *bool `json:"inCluster,omitempty" tf:"in_cluster,omitempty"`
}

type EncryptionInfoObservation struct {
}

type EncryptionInfoParameters struct {

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-aws/apis/kms/v1beta1.Key
	// +crossplane:generate:reference:extractor=github.com/upbound/official-providers/provider-aws/config/common.ARNExtractor()
	// +kubebuilder:validation:Optional
	EncryptionAtRestKMSKeyArn *string `json:"encryptionAtRestKmsKeyArn,omitempty" tf:"encryption_at_rest_kms_key_arn,omitempty"`

	// +kubebuilder:validation:Optional
	EncryptionAtRestKMSKeyArnRef *v1.Reference `json:"encryptionAtRestKmsKeyArnRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	EncryptionAtRestKMSKeyArnSelector *v1.Selector `json:"encryptionAtRestKmsKeyArnSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	EncryptionInTransit []EncryptionInTransitParameters `json:"encryptionInTransit,omitempty" tf:"encryption_in_transit,omitempty"`
}

type FirehoseObservation struct {
}

type FirehoseParameters struct {

	// +kubebuilder:validation:Optional
	DeliveryStream *string `json:"deliveryStream,omitempty" tf:"delivery_stream,omitempty"`

	// +kubebuilder:validation:Required
	Enabled *bool `json:"enabled" tf:"enabled,omitempty"`
}

type JmxExporterObservation struct {
}

type JmxExporterParameters struct {

	// +kubebuilder:validation:Required
	EnabledInBroker *bool `json:"enabledInBroker" tf:"enabled_in_broker,omitempty"`
}

type LoggingInfoObservation struct {
}

type LoggingInfoParameters struct {

	// +kubebuilder:validation:Required
	BrokerLogs []BrokerLogsParameters `json:"brokerLogs" tf:"broker_logs,omitempty"`
}

type NodeExporterObservation struct {
}

type NodeExporterParameters struct {

	// +kubebuilder:validation:Required
	EnabledInBroker *bool `json:"enabledInBroker" tf:"enabled_in_broker,omitempty"`
}

type OpenMonitoringObservation struct {
}

type OpenMonitoringParameters struct {

	// +kubebuilder:validation:Required
	Prometheus []PrometheusParameters `json:"prometheus" tf:"prometheus,omitempty"`
}

type PrometheusObservation struct {
}

type PrometheusParameters struct {

	// +kubebuilder:validation:Optional
	JmxExporter []JmxExporterParameters `json:"jmxExporter,omitempty" tf:"jmx_exporter,omitempty"`

	// +kubebuilder:validation:Optional
	NodeExporter []NodeExporterParameters `json:"nodeExporter,omitempty" tf:"node_exporter,omitempty"`
}

type ProvisionedThroughputObservation struct {
}

type ProvisionedThroughputParameters struct {

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeThroughput *float64 `json:"volumeThroughput,omitempty" tf:"volume_throughput,omitempty"`
}

type PublicAccessObservation struct {
}

type PublicAccessParameters struct {

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type S3Observation struct {
}

type S3Parameters struct {

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-aws/apis/s3/v1beta1.Bucket
	// +kubebuilder:validation:Optional
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// +kubebuilder:validation:Optional
	BucketRef *v1.Reference `json:"bucketRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	BucketSelector *v1.Selector `json:"bucketSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	Enabled *bool `json:"enabled" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type SaslObservation struct {
}

type SaslParameters struct {

	// +kubebuilder:validation:Optional
	IAM *bool `json:"iam,omitempty" tf:"iam,omitempty"`

	// +kubebuilder:validation:Optional
	Scram *bool `json:"scram,omitempty" tf:"scram,omitempty"`
}

type StorageInfoObservation struct {
}

type StorageInfoParameters struct {

	// +kubebuilder:validation:Optional
	EBSStorageInfo []EBSStorageInfoParameters `json:"ebsStorageInfo,omitempty" tf:"ebs_storage_info,omitempty"`
}

type TLSObservation struct {
}

type TLSParameters struct {

	// +kubebuilder:validation:Optional
	CertificateAuthorityArns []*string `json:"certificateAuthorityArns,omitempty" tf:"certificate_authority_arns,omitempty"`
}

// ClusterSpec defines the desired state of Cluster
type ClusterSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ClusterParameters `json:"forProvider"`
}

// ClusterStatus defines the observed state of Cluster.
type ClusterStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Cluster is the Schema for the Clusters API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aws}
type Cluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ClusterSpec   `json:"spec"`
	Status            ClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterList contains a list of Clusters
type ClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Cluster `json:"items"`
}

// Repository type metadata.
var (
	Cluster_Kind             = "Cluster"
	Cluster_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Cluster_Kind}.String()
	Cluster_KindAPIVersion   = Cluster_Kind + "." + CRDGroupVersion.String()
	Cluster_GroupVersionKind = CRDGroupVersion.WithKind(Cluster_Kind)
)

func init() {
	SchemeBuilder.Register(&Cluster{}, &ClusterList{})
}
